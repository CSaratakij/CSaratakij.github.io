<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>Doppelganger | CSaratakij</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />

  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.de1463cdda2e8900da531c8499bc4e4bf0e9a5c49301e66402b46abbc21e0875.css" integrity="sha256-3hRjzdouiQDaUxyEmbxOS/DppcSTAeZkArRqu8IeCHU="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css" integrity="sha256-47DEQpj8HBSa&#43;/TImW&#43;5JCeuQeRkm5NMpJWZG3hSuFU="/>
  
  
   
   
    

<script type="application/ld+json">
  
    { 
      "@context": "http://schema.org", 
      "@type": "WebSite", 
      "url": "https:\/\/csaratakij.github.io\/projects\/doppelganger\/",
      "name": "Doppelganger",
      "author": {
        "@type": "Person",
        "name": ""
      },
      "description": ""
    }
  
  </script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/">about</a>
      </li>
    
      <li>
        <a  class="active"
         href="/projects">projects</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">Doppelganger</h1>
            <time datetime="2020-09-02 09:11:33 &#43;0700 &#43;07" class="post__date">Sep 2 2020</time> 
          </header>
          <article class="post__content">
              
<p>The puzzle platformer with a twist. Player can use a “Focus” power, the ability to bend a dimension to overcome the obstacle.</p>
<p><img src="/dg-cover.png" alt="Doppelganger"></p>
<p>game: <a href="https://csaratakij.itch.io/doppelganger">https://csaratakij.itch.io/doppelganger</a><br>
walkthrough: <a href="https://www.youtube.com/watch?v=t01DpSmG0PQ">https://www.youtube.com/watch?v=t01DpSmG0PQ</a><br>
respository: <a href="https://github.com/CSaratakij/DG-Script-Only">https://github.com/CSaratakij/DG-Script-Only</a></p>
<p>responsible: game system</p>
<p>other member:<br>
<a href="mailto:nutthanlekprasan@outlook.co.th">Nutthan Lekprasan</a> (game designer)<br>
<a href="mailto:jetniphatoat@gmail.com">Jetniphat Likhitwatthanasakun</a> (artist)</p>
<h2 id="introduction">Introduction<a class="anchor" href="#introduction">#</a></h2>
<p>Before you read any further, I have to warn you. There are some <strong>spoiler</strong> of the puzzle in this game. Please play the game first to avoid any spoiler.</p>
<p>This game is the entry for <strong>The Twentieth National Software Contest: NSC 2018</strong>.
We have about <strong>3 months</strong> to finish this project.</p>
<p>We manage to get the <strong>2nd runner up</strong> in <em><strong>&ldquo;Program for entertainment&rdquo;</strong></em> .</p>
<p>Since I mainly do a game system and some of the game design, I will cover these topics with in depth. However, I will leave the art aspect to the
artist himself.</p>
<h2 id="why-this-game-call-doppelganger">Why this game call &ldquo;Doppelganger&rdquo;<a class="anchor" href="#why-this-game-call-doppelganger">#</a></h2>
<p>If you already play the game, you will notice that there isn&rsquo;t a single doppelganger in this game.
We name this game <strong>&ldquo;Doppelganger&rdquo;</strong> at first because we want the game to do something about a clone of our player character.</p>
<p>Turns out, none of the things we discuss in the early stage made it into the final product.
Most of the things in the game come from a first month we made doing a rappid prototype and play testing a lot.</p>
<p>But this is the entry for the contest, We cannot change our name mid-way due to the proposal we sent during the first round of the competition. So we kinda have to live with that.</p>
<h2 id="the-origin-of-the-focus-ability">The origin of the &ldquo;Focus&rdquo; ability<a class="anchor" href="#the-origin-of-the-focus-ability">#</a></h2>
<p><img src="/dg-focus.png" alt="focus ability"></p>
<p>Once we decide this is gonna be a 2d side scroller, I finish implementing the player controller shortly after that.
But there is no core gameplay loop yet. So I have to experiment something quick.</p>
<p>During that time, I saw a game that playing with a clone of player concept like our early idea.
I don&rsquo;t remember the exact name of this game, but the mechanic is very similar to <strong>&ldquo;Binary Land&rdquo;</strong>.</p>
<p>That&rsquo;s when I realized, I actually didn&rsquo;t think about this enough. So I start looking for the inspiration in <a href="https://itch.io">itch.io</a>.</p>
<p>After playing a bunch of weird game, One of the idea come up to my mind.</p>
<p>I remember playing some space shooter game that have a wrapping machanic.
If you go near the end of the screen, you will wrap yourself back to the opposite side of the screen you came from.</p>
<p>I think this is quite interesting, what if a 2d side scroller can do that?<br>
So, I do a quick prototype and make our play testing.</p>
<p>We kinda have a short discussion about how this can work with our doppelganger idea.</p>
<p>Then one of my team notice the similarity in the game that already publish.
That game is <a href="https://store.steampowered.com/app/337490/Four_Sided_Fantasy/">Four Sided Fantasy</a> (<strong>Damn</strong>&hellip;It&rsquo;s hard to be original these day).</p>
<p>Actually, I don&rsquo;t mind if this game is similar to that game and I really like this mechanic.
But I have to keep exploring this deeper to see the other possibility, What cools thing we can do, if player have an ability to wrap themself?</p>
<p>One of the thing I remember experiment with was&hellip;</p>
<p>&quot; What if the world wrapping box place outside of the player and it isn&rsquo;t the thing that player can control and it just sit there in the level? &quot;<br>
<figure>
    <img src="/dg-no-cake.jpg"
         alt="( Sorry, no cake for you )"/> <figcaption>
            <p>( Sorry, no cake for you )</p>
        </figcaption>
</figure>
</p>
<p>There is other problem as well, the gating problem.</p>
<p><strong>Gating</strong> is how the game limit the player progression, in this case is how to prevent player to bypass our obstacle with ease.</p>
<p>The normal obstacle in the 2d side scroller is the height of the wall. But the world wrapping mechanic is really an over power ability.
It can bypass this type of obstacle easily and making it harder to design the game level around this.</p>
<p>This is especially true if the world wrapping box size itself fit to the entire screen.
So, I decide to just nerf this ability.</p>
<p>Instead of making it fit to the whole screen, Why not shrink it down to the smaller size and just place those world wrapping box at the center of the player.</p>
<p>I make a play testing again, and give this prototype to our game designer.</p>
<p>I let him come up with the combination of the level with this over power ability in mind. (a lot of his levels appear in the final product as well)</p>
<p>Once I tested, I quickly realized&hellip;</p>
<p>&ldquo;You know what?, this <strong>world wrapping mechanic</strong> can make the typical puzzle in <strong>puzzle platformer</strong> much more <strong>interesting</strong>.&rdquo;</p>
<p>So I decide to combine puzzle platformer with the world wrapping mechanic (focus), and it turns out to be fun.</p>
<p>Now we have a core gameplay loop.</p>
<p>A short term goals of the player is to figure out how to keep progressing further by solving the well place obstacle with a focus ability.</p>
<p>At the end, our entire month was gone. But we have a strong starting point and an interesting mechanic worth exploring.</p>
<h2 id="things-that-i-implemented">Things that I implemented<a class="anchor" href="#things-that-i-implemented">#</a></h2>
<p>This is the technical aspect of the project and it&rsquo;s quite long.
If you aren&rsquo;t interested in this topic, you can skip to <a href="#how-we-design-a-game-pacing">How we design a game pacing</a> .</p>
<h3 id="game-system">Game System<a class="anchor" href="#game-system">#</a></h3>
<h4 id="player-controller">Player Controller</h4>
<p><img src="/dg-player-controller.png" alt="player controller"></p>
<p>This is the first thing I finished implementing.</p>
<p>Without knowing what the game is gonna look like at first, I took an
easiest way possible to approach this by making it based on the physics engine.</p>
<p>In which you can call this a <strong>&ldquo;Physics based platformer&rdquo;</strong>.</p>
<p>As the result, I have to fight the physics engine because in reallity the character wasn&rsquo;t behave
in the way the normal physics would behave as the physics engine estimate.</p>
<p>The better ways to do the platformer in general is to not rely on the
physics engine and roll your own based on the specific need of your current project.</p>
<p>All the physics based platformer suffer from the floatlyness in which is
the feeling of not in control of character.</p>
<p>Making the tight platformer controls by based around the physics engine
it&rsquo;s just a brute force process of tweaking a multiple parameters of the physics engine to get the result closest to what you want.</p>
<p>There is still a cost to pay, because the root cause of the floatlyness is
not resolve.</p>
<p>All you can do is to mitigate its effect.<br>
Take a look at <a href="https://store.steampowered.com/app/504230/Celeste">Celeste</a>.</p>
<p>One of the game that have a tight and satify player controller in the
platformer genere.</p>
<p>They need to nail this stuff, because in Celeste there are a ton of
platform session that require a percise jump from the player.</p>
<p>This is not possible if you based it around a physics engine.</p>
<p>Lucky for me, this game is not really having a lot of the platform session
and it didn&rsquo;t require a percise jump.</p>
<p>This allow me to focus on the other aspect of the project without having
to re-implement the player controller.</p>
<p>Although, I love a tight control feeling of the platformer in general.
(Like in <strong>Celeste</strong>)</p>
<p>If I have a chance to remake this game, This will be the first thing I want to re-implement.</p>
<p>Now, let&rsquo;s talk about the implementation detail of player controller.</p>
<p><strong>Walking</strong></p>
<p>Nothing fancy here.</p>
<p>Just get the move direction from the input and move its character according to its move speed.</p>
<p>Since I use the physics engine, I need to add a physics material and low
the friction value to 0 to prevent its collider from getting stuck when character is in the air while bumping to the wall.</p>
<p>The footstep sound effect will play while character moving around, and its sound effect will pick based on the game object tag that found by a simple raycast.</p>
<p>As for the movement when staying on top of the platform, I translate character with the same velocity as the platform itself whenever
player found a platform by overlap testing around the feet of character.</p>
<p><strong>Jumping</strong></p>
<p>There are low and high jump in this game.</p>
<p>This is possible by manipulate a gravity based on the way player press their jump button.</p>
<p><img src="/dg-jump-curve.jpg" alt="jump curve"></p>
<p>Normally, player will experience a normal gravity.</p>
<p>At the moment player starting to press the jump button, I will add the upward force to the character once.</p>
<p>After that, I still checking for the key press but it won&rsquo;t add the force
to the character anymore.</p>
<p>If player keep holding down the jump button until the character starting
to fall, player will experience the normal gravity.</p>
<p>But if player release their jump button before the character reach to the highest jump possible,
player will experience a higher gravity forcing the character to fall down sooner than it would normally be.</p>
<p>As for the ground detection, I use overlap testing instead of the multiple
raycast.</p>
<p>The issue that come with this is I have to avoid unnecessary allocation at every fixed update cycle.</p>
<p>Because, I don&rsquo;t want a Garbage Collector (GC) to kick in cleaning the
stuff during gameplay making it look like a random freeze (spike) in the player perspective.</p>
<p>So, I have to pre-allocate, make a buffer and change the overlap testing method to the stuff that support a buffer.</p>
<p>The wall jumping mechanic is using a ray cast around a character feet to check if there is a wall at the same direction that player is currently
facing.</p>
<p>If it successfully detect the wall, player will get the additional jump at about 63 degree up.</p>
<p>One way collision is using a built in Unity solution.</p>
<p><strong>Push &amp; Pull box</strong></p>
<p><img src="/dg-box-pull-push.png" alt="push and pull box"></p>
<p>Push and pull box have two states.</p>
<p><strong>Before grab</strong></p>
<p>The box will have a mass different than a player character to prevent it from moving with a simple bump from the character collider.</p>
<p>If player getting closer to a box, it will show which key to make player able to grab itself.</p>
<p><strong>During grab</strong></p>
<p>After player successfully grab a box, it will move along with the
character.</p>
<p>It will keep checking if player is still closer to the box by simply overlap testing.</p>
<p>I have to keep testing it during fixed update cycle because the OnTriggerStay message is not a reliable way to test if something is still overlaping on something.</p>
<p>The area of testing is draw by using a Gizmos, a yellow rectangle that
surround the box.</p>
<p>If player stop overlapping to the area of testing, I will stop player from grabbing a box.</p>
<h4 id="camera-system">Camera System</h4>
<p>I use orthogonal view as a default. ( Of course, It&rsquo;s a 2d game anyway )</p>
<p>The reason I support only <strong>16:9 screen ratio</strong> is because this game puzzle is playing with a camera and design with this screen ratio as a default.</p>
<p>At the moment player use the focus ability, the camera will freeze limit how much player will see the level.</p>
<p>With this design choice, some of the game puzzle cannot be solve without this screen ratio.</p>
<p>These are the things that I implement as a part of the camera system.</p>
<p><strong>Camera Follow</strong></p>
<p>This use mainly by a player controller but also by the game cinematic to
make a camera focus and follow the target.</p>
<p>It has an offset setting, mainly use to shift the camera upward to avoid too much wasted space of the screen when trying to focus on the player
but didn&rsquo;t want the player to see much of the ground sprite.</p>
<p>By combine offset setting with a camera trigger, it can be use to avoid
a <strong>blind jump</strong> by shifting the camera to the appropriate offset within the given situation.</p>
<p><strong>Blind Jump</strong> is a situation where player don&rsquo;t know where their character is gonna land if they starting to jump.</p>
<p>As a platformer, it&rsquo;s best to avoid this situation at all cost.<br>
Take a look at this image.</p>
<p><img src="/dg-blind-jump.png" alt="blind jump example"></p>
<p>How player gonna know where their character is gonna land if they initiate the jump to the right?</p>
<p><strong>Camera Trigger</strong></p>
<p>This use to change the camera setting and trigger the game cinematic when player enter the trigger area.</p>
<p>The area is draw by Gizmos using a blue rectangle to represent the trigger area.</p>
<p><img src="/dg-camera-offset-trigger.png" alt="camera offset trigger"></p>
<p>I have to make it this large, because player can bypass a small area by using a focus ability.</p>
<p><strong>Game Cinematic</strong></p>
<p>This is a part of the camera system.</p>
<p>At that time, the Unity Timeline tools which is suppose to help making a game cinematic easier is still in alpha.</p>
<p>I play around with this tools a little bit and it sad to say that this tools is not gonna work at the time we develop this game.</p>
<p>I kinda want to implement just a necessary feature like the thing in the Unity Timeline to help our life easier but we don&rsquo;t have a time to actually pull this off.</p>
<p>So, I decide to just stick with a simple cinematic possible. Something like, just make a camera focusing on some target.</p>
<p>This allow me to re-use our camera stuff like for example a <strong>Camera Follow</strong>.</p>
<p>And other stuff that require a logic to work other than a camera in the
game cinematic, I&rsquo;ll just code it specifically for that scene.</p>
<p>And it works perfectly, I don&rsquo;t have to spend too much time on a game cinematic and have an extra time to do something else.</p>
<h4 id="world-wrapping-mechanic-focusdont-forget-about-the-sprite-mask-box-effect-by-focus">World Wrapping Mechanic (Focus)(don&rsquo;t forget about the sprite mask, box effect by focus)</h4>
<p><img src="/dg-focus-wrapping.png" alt="world wrapping mechanic"></p>
<p>This one is the most challenge things to implement in this project, took me sometime to figure out.</p>
<p>The actual world wrapping logic is not really that hard, but the hard thing is to come up with a general case for the ability itself.</p>
<p>Because it shouldn&rsquo;t need to have a special case for a particular level.</p>
<p>Anyone that responsible for placing a level itself shouldn&rsquo;t have to place some
magic trigger at a specific place in the level to actually make this
works.</p>
<p>It should just work consistently with any level that we throw at it.</p>
<p>Let&rsquo;s start with a basic of this ability, the focus (normal mode).</p>
<p><strong>Normal Mode</strong></p>
<p>The focus ability as a text is simple, It&rsquo;ll wrap player back to the opposite side of where they came from.</p>
<p>But what it actually mean to wrap themself back?</p>
<p>Take a look at this situation.</p>
<p><img src="/dg-wrapping-problem.jpg" alt="wrapping problem"></p>
<p>Assume the focus ability frame is cover the entire screen.
If player going to point A, do they wrap themself back to point B?</p>
<p>If they wrap themself back to point B, then how about this normal situation?</p>
<p><img src="/dg-wrapping-diagonal.jpg" alt="diagonal wrap"></p>
<p>If those assumption is correct, then does it mean the wrapping mechanic wrap player diagonally?</p>
<p>In the player perspective, this looks weird.</p>
<p>What player expect in this normal situation is to wrap themself horizontally.</p>
<p><img src="/dg-wrapping-horizontal.jpg" alt="horizontal wrap"></p>
<p>If I want to make the normal case to work as aspect, I have to think about the general case that will explain these two situation perfectly.</p>
<p>And that general case is what I call the <strong>&ldquo;Absolute Wrapping&rdquo;</strong></p>
<p><strong>Absolute Wrapping</strong> is an approach to look at this problem by taking the
strong stand on the world wrapping.</p>
<p>The idea is simple.</p>
<p>If there is an empty space that player can fit through, player can wrap themself back regardless of the starting position of the player.</p>
<p><img src="/dg-wrapping-one-approach.jpg" alt="wrapping approach one"></p>
<p>For example. As long as there is an empty space, player can go to the opposite side in which the player start position&rsquo;s height
don&rsquo;t have to be the same height after finish wrapping.</p>
<p>But there is an issue with this approach.<br>
Not the technical stuff, but the design decision.</p>
<p>If I implement this in the Absolute Wrapping way, It&rsquo;s kinda broke the level.
(Gating problem)</p>
<p>This mechanic will be too powerful and can bypass any obstacle with ease.</p>
<p>By making this ability too powerful, I accidentally downgrade this ability to be use as a gimmick.</p>
<p>I want player to rely on the focus ability as the key to solve the
puzzle.</p>
<p>If this ability is not only easy to use but also make player not to think about the puzzle at all while activating this, It&rsquo;s kinda defeat the purpose of this game.</p>
<p>Imagine you develop a game about lock picking.</p>
<p>And from the start instead of giving player the lock picking tools, You give player the master key to unlock anything.
(What&rsquo;s the point of the lock picking then?)</p>
<p>But there is still a hope.<br>
There is other way to think about the world wrapping.</p>
<p><strong>KISS Wrapping</strong> or keep it simple (stupid) wrapping is the simpler way to world
wrapping in which it will only wrap player per axis at a time.</p>
<p><img src="/dg-wrapping-kiss.jpg" alt="wrapping kiss"></p>
<p>For example. If player come from the left side, It will wrap player to the right side.</p>
<p>But instead of looking for any potential empty space, the left and right is clearly the horizontal axis.</p>
<p>So, It&rsquo;s gonna wrap player only x axis and keep the y axis as the same value before wrapping.</p>
<p>This mean player cannot wrap themself to the other side when their height is not the same as the wrapping destination.</p>
<p>The same thing also apply when player wrapping vertically.</p>
<p>If player come from the lower side, it&rsquo;s gonna wrap player to the upper
side while keep the x axis value.</p>
<p>With this nerf, the gating problem is easier to solve. Allow us to make some interesting obstacle.</p>
<p>But this approach also have its own set of problem, I cannot blindly wrap player.</p>
<p>Because if I do, player will get stuck in other collider.
Like a wall or a ground in player perspective.</p>
<p><img src="/dg-wrapping-stuck.jpg" alt="stuck with wall while wrapping"></p>
<p>So, I have to come up with a way to check if the wrapping destination is safe before beginning to wrap player.</p>
<p>Now, let&rsquo;s dive into the implementation detail to see how it&rsquo;s done.</p>
<p><strong>Wrapping Character Back</strong></p>
<p>Assume the wrapping destination is safe.</p>
<p>When half of character reach the edge of the focus frame,
I&rsquo;ll set character a new position to the opposite side depending on the side of the focus that character enter.</p>
<p>It&rsquo;s like character just do a teleportation.</p>
<p><img src="/dg-focus-wrapping-01.png" alt="near the edge"></p>
<p>The actual frame size of focus is store using the world coordinate position and its size (width, height).</p>
<p>To mask character within the frame, I use the built in Sprite Mask.</p>
<p>The sprite of mask itself is just a one unit sprite that scale its size to match the focus frame size at runtime.</p>
<p>The solid frame is a built in Unity Line Renderer.</p>
<p>And a necessary focus frame decoration at the edge of this frame is just a sprite that place at runtime by finding
an edge world coordinate from the format that focus frame use.</p>
<p><strong>Limit Wrapping Capability</strong></p>
<p>There is a situation where character won&rsquo;t be safe to go to the wrapping destination.</p>
<p>In this image, you can see the focus frame itself overlap to the wall
on the left.</p>
<p><img src="/dg-wall-stuck-explain.png" alt="wall stuck situation"></p>
<p>When this happen, there is an invisible wall to prevent character from reaching the edge of the focus frame by a half of character.</p>
<p>I will refer the invisible wall as a <strong>blocker</strong>.</p>
<p><img src="/dg-blocker-01.jpg" alt="blocker"></p>
<p><strong>Blocker</strong> is just a collider that I control its position during runtime.</p>
<p>Since I use physics engine in <strong>Player Controller</strong>, I&rsquo;ll let physics engine handle the collision resolution between player character
and the blocker.</p>
<p>In the normal situation, there are blockers on each side of the focus frame.</p>
<p><img src="/dg-blocker-02.jpg" alt="blocker with 4 axis"></p>
<p>Each blocker will keep its distance away from focus frame to make sure player can do the world wrapping.</p>
<p>To make thing simple, let&rsquo;s focus on just one blocker.</p>
<p>In order to make sure that player can go to the wrapping destination,
I have to make a quick overlap testing to see if there is enough space for this character to wrap.</p>
<p>In this case, character come from the right side.</p>
<p>So, I have to overlap testing on the left side which use the same width and height as the character to test other collider.</p>
<p>[image that explain the concept here]</p>
<p>If the testing pass, I&rsquo;ll leave the blocker away from the focus frame.</p>
<p>But, If the overlap testing fail, I&rsquo;ll move the blocker as close as the focus frame to block player from moving closer to the edge of the focus.</p>
<p>[image that explain the concept here]</p>
<p>Not all blockers will be move, It&rsquo;ll pick only the blocker at the same side of the wrapping destination.</p>
<p>But there is other interesting situation here.<br>
What if there is enough space on the wrapping destination?</p>
<p><img src="" alt="image about first tutorial about its limit here"></p>
<p>If you guess player can freely move to the left side, then you wrong.</p>
<p>Remember that the KISS Wrapping <strong>doesn&rsquo;t care</strong> about <strong>any potential empty space</strong>, It&rsquo;s care only if player can wrap to the other side.</p>
<p>In this case, the area of overlap testing looks like this.</p>
<p>[image here]</p>
<p>As you can see, player wrapping horizontally.</p>
<p>So, It&rsquo;s testing area will only care about x axis and keep the y axis.</p>
<p>The result of overlap testing will fail, because it&rsquo;s overlap with a tiny ground collider at the right side.</p>
<p>But, If player height change.<br>
Now, the overlap testing area look like this.</p>
<p>[image here]</p>
<p>Overlap testing result will pass, this allow player to go to the wrapping destination by jumping to the left side.</p>
<p>This is what it looks like in the Unity Editor.</p>
<p>[video here..]</p>
<p>The blocker will keep jumping back and forth between trying to block player and to not block player.</p>
<p>But, there is a consequence.<br>
The same thing apply to vertical axis.</p>
<p>With this implementation, it allow us to do something like this.</p>
<p><img src="/dg-build-ground.png" alt="wrapping general case consequence"></p>
<p>Because player cannot go to the upper side, It&rsquo;s block player from going to the lower side.</p>
<p>Accidentally, making a convenient ground for player.</p>
<p><strong>Move Mode</strong></p>
<p><img src="/dg-focus-movemode.png" alt="focus move mode"></p>
<p>(check frame position, if it possible to place in that position (clamp to not geater than the whole viewport))
(don&rsquo;t allow player to activated this ability when jump)</p>
<p><strong>Edit Mode</strong>
(image about edit mode here)
(check frame position, if it possible to place in that position)</p>
<p>(summary of world wrapping mechanic)
(don&rsquo;t forget to box effect by focus)
<img src="/dg-box-effect-by-focus.png" alt="box effect by focus"></p>
<h4 id="gamepad-support">GamePad support</h4>
<p>(XInput, Direct Input here (why use direct input as a fall back))
(polling gamepad connection here..)</p>
<h4 id="game-progress">Game Progress</h4>
<p>(Json saving, miss oppotunity to save as async here&hellip;)
(Save progress in runtime, serialize once)
(Load on game start)</p>
<h4 id="door--switch">Door &amp; Switch</h4>
<p><img src="/dg-door-and-switch.png" alt="door and switch"></p>
<h4 id="moving-platform">Moving Platform</h4>
<p>(todo) This is the small price I have to pay for using physics based platformer.
(kinematic and gizmos here&hellip;)</p>
<h4 id="collectable">Collectable</h4>
<p>(photo here.., integrate with game progress (system))</p>
<h4 id="game-ui">Game UI</h4>
<p>(TODO)
Unity Canvas do the jobs nicely</p>
<p>(TODO)
I avoid Unity Event and its messaging system since it&rsquo;s slower than manually binding a native C# event.
( Even though it&rsquo;s less convenient to setup )</p>
<h4 id="loading-screen">Loading Screen</h4>
<p><img src="/dg-loading-screen.png" alt="loading screen">
(load scene async make it possible)</p>
<h3 id="custom-editor">Custom Editor<a class="anchor" href="#custom-editor">#</a></h3>
<p>Unity have a way to extend an editor to suit our project need.<br>
We definitely take advantage of this.</p>
<p>These are the tools I built to help reduce our development time.<br>
We cannot hope to quickly iterate our levels and finish this project without these tools.</p>
<h4 id="save-id-generator">Save ID Generator</h4>
<p><img src="/dg-save-id-generator.png" alt="save id generator"></p>
<p>This tools help ensuring our checkpoint to have a unique ID.</p>
<p>Because we iterate a lot of levels in a short period of time, we keep adding, changing its location and removing the
checkpoint overtime.</p>
<p>Without this tools, we have to keep checking every checkpoint we place manually to make sure its ID will not conflict with each other.<br>
(Which is really time consuming process)</p>
<p>With this tools, we can check and re-generate every checkpoint ID in one click. This help ensuring our save and load system working properly.</p>
<p>One of the problem I came across is how to make Unity save the
change we made programmatically.</p>
<p>To make this tools work, I have to push our change to the Unity undo stack.</p>
<p>Once our change has pushed, It will set the Unity scene dirty and allow us
to save the scene. (I learn this the hard way&hellip;)</p>
<p>You can view the implementation <a href="https://github.com/CSaratakij/DG-Script-Only/blob/develop/Assets/Editor/SaveSetting.cs">here</a> .</p>
<h4 id="collision--collider-plotter">Collision &amp; Collider Plotter</h4>
<p><img src="/dg-collision-plotter.png" alt="collision plotter"></p>
<p>This tools help us create and delete our collision and collider quickly with ease.</p>
<p>We need this tools because of the problem about the way Unity resolve its collision.</p>
<p>Take a look at this example.</p>
<p><img src="/dg-sprite-each-collision.png" alt="sprite have its own collision"></p>
<p>As you can see, each of the sprite has its own box collider.</p>
<p>The problem here is that, player will get stuck at some point when they try to walk on this type of the collider setup.</p>
<p>Despite how it look, a bunch of smaller box collider cannot provide a seemless ground surface.</p>
<p>Physics engine try to push away each pair of the collider when it detects the collision in each fixed update to prevent them from overlap to each other.</p>
<p><img src="/dg-player-stuck-sample.png" alt="player stuck"></p>
<p>To keep things simple, let assume there are the two possibilities at the moment player collider overlap to the edge of the ground collider.</p>
<p><strong>Vertical Push</strong></p>
<p><img src="/dg-push-to-vertical-arrow.png" alt="vertical push"></p>
<p>As you can see, the length of overlapping in the horizontal axis is greater than the vertical axis.</p>
<p>So, the quickest way to push each collider away from each other is by pushing them vertically.</p>
<p><strong>Horizontal Push</strong></p>
<p><img src="/dg-push-to-horizontal-arrow.png" alt="horizontal push"></p>
<p>In this case, pushing each collider pair horizontally would be the quickest way to resolve this collision.</p>
<p>But this also the cause of the player getting stuck, because player keep getting push back to the opposite way of the way they want their character to be move.</p>
<p>For example, player might be able to walk in the right direction. But as soon as they start walking in the left direction, their character might get stuck.</p>
<p>The ideas box collider setup would be a big box collider to make physics engine resolve collision correctly.</p>
<p><img src="/dg-sprite-one-big-collision.png" alt="one big box collider"></p>
<p>But, the box collider size also adjust to the same size of the sprite when you add its component to the sprite itself.</p>
<p>So we have to seperate the collider from the sprite by making an empty game object attached with the box collider component.</p>
<p>Placing this ideas box collider with an existing Unity tools is really time consuming.</p>
<p>Not only we have to keep our box collider size right, we have to place this in the proper distance (make it snap to the grid).</p>
<p>The way I do this is using the fact that I can construct a rectangle by using only two points.
<img src="/dg-A-B.png" alt="construct rectangle by two points"></p>
<p>And the grid itself is just the default Unity scene view grid.</p>
<br/>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/5gCgzt1DCqA" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>This tools also help us placing the necessary collider to represent the ground material to help playing the right sound of player footstep.</p>
<p>You can view the implementation <a href="https://github.com/CSaratakij/DG-Script-Only/blob/develop/Assets/Editor/Plotter/CollisionPlotter.cs">here</a> .</p>
<h4 id="sprite-plotter">Sprite Plotter</h4>
<p><img src="/dg-sprite-plotter.png" alt="sprite plotter"></p>
<p>This tools help our artist to quickly place the tilesets.</p>
<p>Since we use a pixel art style for this game, We need to make sure each sprite will align properly within the grid.</p>
<p>At that time, Unity already have a tools to help place the tilesets.<br>
Unfortunately, We don&rsquo;t want to use its solution.</p>
<p>Not only it techically still in the beta, but also the amount of work we have to do in order to prepare our sprite is way too much for our use case.</p>
<p>We just want to snap our sprite to the grid. ( for god sake&hellip; )</p>
<p>That&rsquo;s why this tools was created.<br>
The placing sprite logic is similar to the <strong>Collision &amp; Collider
Plotter</strong>.</p>
<p>One issue I have to deal is to prevent too much waste in the game object when placing the multiple sprites that use the same texture.</p>
<p>Lucky for me, I can change the sprite draw mode to tile to make texture repeat itself to fit the size of the sprite.</p>
<p>This help us reduce game object count to just one per multiple sprites.</p>
<br/>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/f7WA2ed93RI" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>Later on, I add the brush profile to help group our tilesets together.
Make it easier for the artist to choose the tilesets.</p>
<p>This is possible by the fact that the assets need to generate its own Global Unique Identifier (GUID) when import to the project.</p>
<p>So, I just need to retreive its asset guid then save it in the <a href="https://github.com/CSaratakij/DG-Script-Only/blob/develop/Assets/Editor/Plotter/Profile/dg_grid_preset.json">JSON</a> format.<br>
You can view the implementation <a href="https://github.com/CSaratakij/DG-Script-Only/blob/develop/Assets/Editor/Plotter/SpritePlotter.cs">here</a> .</p>
<h4 id="scene-selector">Scene Selector</h4>
<p><img src="/dg-scene-selector.png" alt="scene selector"></p>
<p>This tools help us play testing the game from the start without having to leave the current scene in the editor.</p>
<p>This feature is what I wish to be built in to the Unity Editor.<br>
But sadly, it&rsquo;s not&hellip;</p>
<p>So, I have to implement this myself.</p>
<p>Let&rsquo;s assume I set the scene name &ldquo;Introduction&rdquo; as the first scene in the build setting.</p>
<p>But I open the scene name &ldquo;Level5&rdquo; in the editor.</p>
<p>If I hit &ldquo;Play&rdquo; button in the editor, Unity by default will play a current scene.
In this case, It&rsquo;s a &ldquo;Level5&rdquo; scene.</p>
<p>If I want to start playing from the &ldquo;Introduction&rdquo; scene, I have to close
the &ldquo;Level5&rdquo; scene first and then have to manually open the &ldquo;Introduction&rdquo; scene before entering the play mode.</p>
<p>Which make me frustrated overtime.<br>
So, this tools keeping me sane while play testing dozen of times.</p>
<br/>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/PaeOfl0nNyM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>You can view the implementation <a href="https://github.com/CSaratakij/SceneSelector">here</a> .</p>
<h2 id="how-we-design-a-game-pacing">How we design a game pacing<a class="anchor" href="#how-we-design-a-game-pacing">#</a></h2>
<p>Once we finished interating a lot of levels and decide which level to keep in the game,
we connect all the levels based on their difficulty and start play testing from the beginning.</p>
<p>Not only to estimate how much time player need to complete this game, but also wanted to see how each level feels when connect to each other.</p>
<p>We re-arrange the order of each level if it necessary and take a note when player starting to feels repetitive.</p>
<p>Then we introduce the new ability or some shift in the game mechanic when player feels repetitive the most.</p>
<figure>
    <img src="/dg-pacing.jpg"
         alt="( This image is a rough approximate of how this game pacing works )"/> <figcaption>
            <p>( This image is a rough approximate of how this game pacing works )</p>
        </figcaption>
</figure>

<p>I strongly disagree about front-load tutorial, so the first two phase of the
game was crafted with extra care to make sure that I introduce player to the game properly.</p>
<p>The idea is simple, introduce player to the concept in the smallest fashion
rather than overwhelm player with too much information at the given time.</p>
<h3 id="beginning-phase">Beginning Phase<a class="anchor" href="#beginning-phase">#</a></h3>
<p>The main goals of this phase is to make player familar with how to control their character.
No mind bending stuff or fancy mechanic would get introduce yet.</p>
<p>At first, I place the level in such a way that player will know exactly which way to proceed. (Just keep going right)</p>
<p><img src="/dg-0.png" alt="beginning-0"></p>
<p>Then I make player warm up their jump by introduce a little platform.</p>
<p><img src="/dg-1.png" alt="beginning-1"></p>
<p>Then, the game will play a tiny cutscene to remind player about going to the right.</p>
<p><img src="/dg-11.png" alt="beginning-11"></p>
<p>Finally, make sure that player know about the high jump (hold a jump button) by placing a taller wall as an obstacle in which player need a box to support the height.</p>
<p>So, this introduce player about how to push and pull a box in the process.</p>
<p><img src="/dg-2.png" alt="beginning-2"></p>
<h3 id="tutorial-phase">Tutorial Phase<a class="anchor" href="#tutorial-phase">#</a></h3>
<p>This phase is to make player understand the basic principle of the main
mechanic. Especially, the focus ability.</p>
<p>This phase also explain the limit of the focus ability as well.</p>
<p>At first, I throw player in the situation where they need to use the focus
ability in order to proceed.</p>
<p>Not only it help player to understand what it capable of, but also how to use it to solve the puzzle as well.</p>
<p><img src="/dg-3.png" alt="tutorial-0"></p>
<p>After that, I introduce its limitation right away. Player need to think
a little bit in order to proceed.</p>
<p><img src="/dg-4.png" alt="tutorial-1"></p>
<p>Then, I teach player about how pressure switch works with a door.</p>
<p><img src="/dg-5.png" alt="tutorial-2"></p>
<p>If player use the focus ability, it will wrap them back exactly at the top
of the switch. Introduce the pressure switch and how it work in the
process.</p>
<p>So, player will start to think about how useful the box would be.</p>
<p><img src="/dg-6.png" alt="tutorial-3"></p>
<p>Later on, I occasionally remind player about how focus ability work.
And introduce other limitation of the focus ability.</p>
<p>In this case, It&rsquo;s about the position of the character when start using the focus ability matter.</p>
<p><img src="/dg-7.png" alt="tutorial-4"></p>
<h3 id="increase-difficulty-to-the-highest">Increase difficulty to the highest<a class="anchor" href="#increase-difficulty-to-the-highest">#</a></h3>
<p>After a lot of simple puzzle to solve that didn&rsquo;t involve the player
timing at all in the tutorial phase, things starting to shift.</p>
<p>At first is to play with the player timing, they need to use and disable
the focus ability at the right time in order to proceed.</p>
<p>Then things will slowly getting harder and weirder, slowly increasing the
difficulty to the highest possible.</p>
<p>Give player some new abilities to play along the way to keep the game fresh.</p>
<p><img src="/dg-8.png" alt="difficulty-0"></p>
<p>And it keep getting harder and harder until the most challenge puzzle in the game.</p>
<p><img src="/dg-9.png" alt="difficulty-1"></p>
<h3 id="slowly-decrease-difficulty-to-the-end">Slowly Decrease difficulty to the end<a class="anchor" href="#slowly-decrease-difficulty-to-the-end">#</a></h3>
<p>After the most challenge puzzle, things will slowly decrease in the difficulty.</p>
<p>But the time player took from the most challenge puzzle to the final level
is not long enough and player need more time to cool their head after
those challenge.</p>
<p>So, I decide to just suddenly drop in difficulty in the final level.
Because in the player mind, they just got enough of the puzzle at this point.</p>
<p>In the end, it&rsquo;s coming together nicely.</p>
<p>The game took about 10 minutes to finish if player know how to solve those puzzles.</p>
<p>Not too long and not too short for the game session.</p>
<h2 id="getting-the-most-out-of-final-round">Getting the most out of final round<a class="anchor" href="#getting-the-most-out-of-final-round">#</a></h2>
<p>In the final round, we have only 10 days left to complete this project.<br>
So we decide to make the most out of it.</p>
<p>One issue that keep ourself to not work as fast as we would like to be is how we keep forgetting how much work left for us to do.</p>
<p>And there isn&rsquo;t a way to tell each person progress, unless we ask each other.</p>
<p>That&rsquo;s why we spent a whole day to just listing all of our work and adapt a kanban board.</p>
<p>Our kanban board rules are simple.<br>
We have <strong>Backlog</strong>, <strong>Todo</strong>, <strong>In-Progress</strong> and <strong>Done</strong>.</p>
<p><strong>Backlog:</strong> is for the task that we need to complete, but it isn&rsquo;t the main focus right now.</p>
<p><strong>Todo:</strong> is for the task that we currently focus. You can put 3 tasks at the maximum into this section.</p>
<p><strong>In-Progress:</strong> is for the task that currently working on. You can put only 1 task at the time into this section.
And you have to remove the task from this section if you stop or finish
the task.</p>
<p><strong>Done:</strong> is for the complete task.</p>
<p>And the top piorities tasks will be tag with a label <strong>&ldquo;urgent&rdquo;</strong>.</p>
<p>With this board, we can finish most of the necessary task.<br>
You can view the board <a href="https://trello.com/b/hVPRrx2p/dg-frame">here</a> .</p>
<h2 id="conclusion">Conclusion<a class="anchor" href="#conclusion">#</a></h2>
<p>(TODO) Shout out to my team, This project won&rsquo;t be possible without them.</p>


              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://csaratakij.github.io/tags/unity/">unity</a>
    </li>
    <li class="tag__item">
        <a class="tag__link" href="https://csaratakij.github.io/tags/nsc2018/">nsc2018</a>
    </li>
    </ul>

 <div class="pagination">
  

  
    <a class="pagination__item" href="https://csaratakij.github.io/projects/pepper-bell-must-be-grilled/">
      <span class="pagination__label">Next Post</span>
      <span class="pagination__title" >Pepper Bell Must Be Grilled</a>
    </a>
  
</div>

          
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
      <a class="social-icons__link" title="Email"
         href="mailto:CSaratakij@gmail.com"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://csaratakij.github.io/svg/email.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" title="GitHub"
         href="https://github.com/CSaratakij"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://csaratakij.github.io/svg/github.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" title="Facebook"
         href="https://facebook.com/CSaratakij"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://csaratakij.github.io/svg/facebook.svg')"></div>
      </a>
    
     
</div>

            <p>CSaratakij © 2020</p>
          </footer>
          </div>
      </div>
      
      <div class="toc-container">
          
        <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#why-this-game-call-doppelganger">Why this game call &ldquo;Doppelganger&rdquo;</a></li>
    <li><a href="#the-origin-of-the-focus-ability">The origin of the &ldquo;Focus&rdquo; ability</a></li>
    <li><a href="#things-that-i-implemented">Things that I implemented</a>
      <ul>
        <li><a href="#game-system">Game System</a></li>
        <li><a href="#custom-editor">Custom Editor</a></li>
      </ul>
    </li>
    <li><a href="#how-we-design-a-game-pacing">How we design a game pacing</a>
      <ul>
        <li><a href="#beginning-phase">Beginning Phase</a></li>
        <li><a href="#tutorial-phase">Tutorial Phase</a></li>
        <li><a href="#increase-difficulty-to-the-highest">Increase difficulty to the highest</a></li>
        <li><a href="#slowly-decrease-difficulty-to-the-end">Slowly Decrease difficulty to the end</a></li>
      </ul>
    </li>
    <li><a href="#getting-the-most-out-of-final-round">Getting the most out of final round</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js" integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr&#43;kQ=" crossorigin="anonymous"></script>
  
  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>

  
    <script src="/js/table-of-contents.js"></script>
  


</body>

</html>
